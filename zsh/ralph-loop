#!/bin/bash
# Note: We don't use 'set -e' because we handle errors gracefully in the loop

# AFK Ralph - runs multiple iterations autonomously
# Usage: ralph-loop <iterations>
# Run in Docker sandbox: docker sandbox run claude ralph-loop 20
#
# Expects in project root:
#   VISION.md  - End-state vision for the project
#   AGENTS.md  - Instructions for AI agents
#   .beads/    - Issue tracking database
#
# Tips applied:
# - Start conservative (10-20 iterations) before scaling
# - Each commit must pass all tests (Keep CI Green)
# - Completion promise for explicit "done" signal

if [ -z "$1" ]; then
  echo "Usage: ralph-loop <iterations>"
  echo ""
  echo "Tip: Start with 10-20 iterations to understand token consumption."
  echo "     A 50-iteration loop can cost \$50-100+ on large codebases."
  exit 1
fi

# Check for required files
if [ ! -f "VISION.md" ]; then
  echo "Error: VISION.md not found. Run 'ralph-init' to create project files."
  exit 1
fi

if [ ! -f "AGENTS.md" ]; then
  echo "Error: AGENTS.md not found. Run 'ralph-init' to create project files."
  exit 1
fi

if [ ! -f "RAILS.md" ]; then
  echo "Error: RAILS.md not found. Run 'ralph-init' to create project files."
  exit 1
fi

if [ ! -f "PROMPT.md" ]; then
  echo "Error: PROMPT.md not found. Run 'ralph-init' to create project files."
  exit 1
fi

BASE_PROMPT=$(cat PROMPT.md)

# Safety guardrail
MAX_SAFE_ITERATIONS=50
if [ "$1" -gt "$MAX_SAFE_ITERATIONS" ]; then
  echo "Warning: $1 iterations exceeds safe limit of $MAX_SAFE_ITERATIONS."
  echo "Are you sure? (y/N)"
  read -r confirm
  if [ "$confirm" != "y" ]; then
    exit 1
  fi
fi

LOG_FILE="ralph-log-$(date +%Y%m%d-%H%M%S).txt"
echo "Starting Ralph loop at $(date)" | tee "$LOG_FILE"
echo "Max iterations: $1" | tee -a "$LOG_FILE"

consecutive_failures=0
MAX_CONSECUTIVE_FAILURES=3

for ((i=1; i<=$1; i++)); do
  echo "" | tee -a "$LOG_FILE"
  echo "=== Iteration $i of $1 ===" | tee -a "$LOG_FILE"

  # Use temp file to capture output while showing it in real-time
  TEMP_OUTPUT=$(mktemp)

  # Build full prompt: base prompt + loop-specific completion signal
  LOOP_SUFFIX="

LOOP MODE INSTRUCTIONS:
- You are running in a loop. Each iteration should complete exactly ONE task.
- Ignore Backlog issues entirely - treat them as invisible.
- After completing one task, simply end your response. Do NOT output <promise>COMPLETE</promise>.
- ONLY output <promise>COMPLETE</promise> if 'bd ready' shows zero ready issues at the START of your run.
- The loop controller will call you again for the next task."

  FULL_PROMPT="${BASE_PROMPT}${LOOP_SUFFIX}"

  # Run claude and capture exit code (don't exit on failure)
  # We run claude in background and monitor for unhandled promise rejections that hang
  iteration_failed=false

  # Start claude in background, capture PID
  claude --dangerously-skip-permissions -p "$FULL_PROMPT" 2>&1 > "$TEMP_OUTPUT" &
  CLAUDE_PID=$!

  # Monitor output file for the hanging error pattern while claude runs
  while kill -0 $CLAUDE_PID 2>/dev/null; do
    # Check for the unhandled promise rejection that causes hangs
    if grep -q "Error: No messages returned" "$TEMP_OUTPUT" 2>/dev/null; then
      echo "Detected hanging error (No messages returned). Killing Claude process..." | tee -a "$LOG_FILE"
      kill $CLAUDE_PID 2>/dev/null
      wait $CLAUDE_PID 2>/dev/null
      iteration_failed=true
      break
    fi
    # Also check for generic unhandled promise rejection patterns
    if grep -q "promise rejected with the reason" "$TEMP_OUTPUT" 2>/dev/null; then
      if grep -q "Error:" "$TEMP_OUTPUT" 2>/dev/null; then
        echo "Detected unhandled promise rejection. Killing Claude process..." | tee -a "$LOG_FILE"
        kill $CLAUDE_PID 2>/dev/null
        wait $CLAUDE_PID 2>/dev/null
        iteration_failed=true
        break
      fi
    fi
    sleep 1
  done

  # Wait for claude to finish (if not already killed) and get exit code
  wait $CLAUDE_PID 2>/dev/null
  exit_code=$?

  # Show output to terminal
  cat "$TEMP_OUTPUT"

  result=$(cat "$TEMP_OUTPUT")
  rm "$TEMP_OUTPUT"

  # Also append to log file
  echo "$result" >> "$LOG_FILE"

  # Check if iteration failed
  if [ $exit_code -ne 0 ]; then
    iteration_failed=true
    echo "Warning: Claude exited with code $exit_code" | tee -a "$LOG_FILE"
  fi

  # Track consecutive failures
  if [ "$iteration_failed" = true ]; then
    consecutive_failures=$((consecutive_failures + 1))
    if [ $consecutive_failures -ge $MAX_CONSECUTIVE_FAILURES ]; then
      echo "Aborting: $MAX_CONSECUTIVE_FAILURES consecutive failures. Check logs for details." | tee -a "$LOG_FILE"
      exit 1
    fi
    echo "Continuing to next iteration... ($consecutive_failures/$MAX_CONSECUTIVE_FAILURES consecutive failures)" | tee -a "$LOG_FILE"
    # Brief pause before retry to avoid hammering on transient errors
    sleep 2
    continue
  fi

  # Reset consecutive failure counter on success
  consecutive_failures=0

  if [[ "$result" == *"<promise>COMPLETE</promise>"* ]]; then
    echo "" | tee -a "$LOG_FILE"
    echo "All issues complete after $i iterations." | tee -a "$LOG_FILE"
    exit 0
  fi
done

echo "" | tee -a "$LOG_FILE"
echo "Completed $1 iterations." | tee -a "$LOG_FILE"
echo "Run 'bd ready' to check remaining work." | tee -a "$LOG_FILE"
